# 类型理论

_2006 年 2 月 8 日星期三首次出版; 2022 年 9 月 6 日星期二实质性修订_

类型论是逻辑学和计算机科学的基础。 我们在这里仅限于概述逻辑学中的一些重要方面。 关于类型在计算机科学中的重要性，我们建议读者参考 Reynolds 1983 和 1985。

-   [第一章帕拉迪斯和罗素的类型理论](#ParaRussTypeTheo)
-   [2 简单类型理论和 λλ\\lambda\-演算](#SimpTypeTheoLCalc)
-   [第三章分支层次与非谓词原则](#RamiHierImprPrin)
-   [第四章类型论/集合论](#TypeTheoTheo)
-   [第五章类型理论/范畴理论](#TypeTheoCatTheo)
-   [第六章类型系统的扩展、多态性、paradiges](#ExteTypeSystPolyPara)
-   [7.单价基础](#UnivFoun)
-   [书目](#Bib)
-   [学术工具](#Aca)
-   [其他互联网资源](#Oth)
-   [相关条目](#Rel)

---

## 1\. 帕萨特与罗素的类型理论

类型论是罗素为了解决他在集合论的解释中发现的一些矛盾而引入的，并在罗素 1903 年的“附录 B：类型论”中引入。 这个矛盾是通过分析康托的一个定理得到的，

F：X→Pow（X）F：X→Pow（X）F：X \\rightarrow \\Pow（X）

（其中 Pow（X）Pow（X）\\Pow（X）是类 X）X）X 的子类的类）可以是满射的;也就是说，FFF 不可能使得 Pow（X）Pow（X）\\Pow（X）的每个成员 bbb 对于 XXX 的某个元素都等于 F（a）F（a）F（a）。 这可以被“直观地”表述为 XXX 的子集比 XXX 的元素多的事实。 这个事实的证明是如此简单和基本，值得在这里给出。 考虑以下 XXX 子集：

A ={x∈X <$x <$F（x）}，A ={x∈X <$x <$F（x）}. A = \\{ x \\in X \\mid x \\not\\in F（x）\\}。

此子集不能在 FFF 范围内。 因为如果 A\=F（a）A\=F（a）A = F（a），对于某个 ε，则

a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ F（a）当且仅当 a ∈ A 当且仅当 a ∈ F（a）当且仅当 a ∈ F（a）当且仅当 a ∈ F（a）当且仅当且仅当 a ∈ F（a）当且仅当且仅当 a ∈ F（a）当且仅当且仅当 a ∈ F（a）当且仅当且

这是一个矛盾。

有些评论是适当的。 首先，证明没有使用排中律，因此是有效的直观。 第二，方法是使用，所谓的 diagonalisation 已经存在于工作的杜波依斯，雷蒙德建设真正的职能增长速度比任何功能在一个给定的序列的职能。

罗素分析了如果我们把这个定理应用于 A 是所有类的类的情况会发生什么，承认有这样一个类。 于是他开始考虑不属于自己的特殊阶级

（\*）R\={w <$w <$w}.（\*）R\={w <$w <$w}.标签 R = \\{ w \\mid w \\not\\in w \\}。

然后我们有了

R∈ R 当且仅当 R <$R. R \\in R \\text{ iff } R \\not\\in R.

看来的确康托已经意识到这样一个事实，即类的所有集不能被认为是一个集。

罗素传达这个问题弗雷格，他的信，连同弗雷格的答案出现在范 Heijenoort 1967 年。 重要的是要认识到，公式（\*）并不适用，因为它是弗雷格的系统。 正如弗雷格自己在给罗素的回信中所写的那样，“一个谓词是由它自身所断定的”这一表述是不确切的。 弗雷格区分了谓词（概念）和对象。 （一阶）谓词适用于对象，但它不能有谓词作为参数。 弗雷格系统中悖论的精确表述使用了谓词 PPP 的*extension*的概念，我们将其命名为 εPεP\\varepatrium P。 重要的公理 V 是：

（公理 V）εP\=εQ <$$> x\[P（x）<$Q（x）\]（公理V）εP\=εQ <$$> x\[P（x）<$Q（x）\]\\tag{公理 V} \\vareps P =\vareps Q \\equiv \\for all x \[P（x）\\equiv Q（x）\]

该公理断言，当且仅当 PPP 和 QQQ 实质上等效时，PPP 的扩展与 QQQ 的扩展相同。 然后，我们可以通过定义谓词来翻译弗雷格系统中的罗素悖论

R（x）当且仅当 P（x）\]R（x）当且仅当 P（x）\] R（x）存在 P\[x = \\vareps P \\wedge \\neg P（x）\]

然后可以用公理 V 以一种关键的方式来检验，

R（εR）R（εR）R（ε R）R（εR）R（\\vareps R）\\equiv \\neg R（\\vareps R）

我们也有矛盾。 （注意，为了定义谓词 RRR，我们在谓词上使用了*impredicative* existential 量化。 可以证明，弗雷格系统的表语版本是一致的（参见 Heck 1996 和 Ferreira 2002 的进一步改进）。

从这个叙述中可以清楚地看出，类型的概念已经出现在弗雷格的著作中：在那里我们发现了对象、谓词（或概念）、谓词的谓词等之间的区别（这一点在奎因 1940 年强调过）。 这种等级被罗素（1959）称为“外延等级”，它的必要性被罗素认为是他的悖论的结果。

## 2\. 简单类型理论与 λλ\\lambda\-演算

正如我们上面看到的，区别：对象，谓词，谓词的谓词，等等， 似乎足以阻止罗素的悖论（这是承认 Chwistek 和拉姆齐）。 我们首先描述类型结构，因为它是在*Principia*，稍后在本节中，我们提出了优雅的公式，由于教会 1940 年基于 λλ\lambda\-演算。 类型可以定义为

1.  三是个人类型
2.  ()()(\\，）是命题的类型
3.  如果 A1，...，AnA 1，...，AnA_1，\ldots，A_n 是类型，则（A1，...，An）（A1，...，An）（A_1，\ldots，A_n）是各个类型 A1，...，AnA 1，...，AnA_1，\ldots，A_n 的对象上的 nnn\-ary 关系的类型

例如，关于个体的二元关系的类型是（i，i）（i，i）（i，i），二元连接词的类型是（（），（））（（），（））（（\\，），（\\，）），关于个体的量词的类型是（（i））（（i））（（i））。

为了形成命题，我们使用这种类型结构：因此 R（a1，.，an）R（a1，.，an）R（a1，\ldots，a_n）是一个命题，如果 RRR 是类型（A1，.，An）（A1，.，An）（A1，\ldots，A_n）并且 aiaia_i 是类型 AiAiA_i，其中 i\= 1，.，ni\= 1，..，ni = 1，\ldots，n。 这个限制使得不可能形成一个形式为 P（P）P（P）P（P）的命题：PPP 的类型应该是（A）（A）（A）的形式，PPP 只能应用于 AAA 类型的参数，因此不能应用于自身，因为 AAA 与（A）（A）（A）不同。

然而，简单类型论不是谓词的：我们可以定义一个类型为（i，i）（i，i）（i，i）的对象 Q（x，y）Q（x，y），

对于所有 P\[P（x）\\supset P（y）\]，

假设我们有两个个体 bbb 和 bbb，使得 Q（a，b）Q（a，b）Q（a，b）成立。 我们可以定义 P（x）P（x）P（x）为 Q（x，a）Q（x，a）。 显然 P（a）P（a）P（a）成立，因为它是 Q（a，a）Q（a，a）Q（a，a）。 因此 P（b）P（b）P（b）也成立。 我们用非谓词的方法证明了 Q（a，b）Q（a，b）Q（a，b）蕴涵 Q（b，a）Q（b，a）Q（b，a）。

替代的更简单的公式，只保留类的概念，类的类，等等， 是由哥德尔和塔斯基提出的 实际上，这个简单的版本是用哥德尔在他 1931 年的文件正式不可判定的命题。 不可判定命题的发现可能是由一个启发式的论证所激发的，即人们不可能将一阶逻辑的完备性定理扩展到类型论（参见他在哥德尔文集第三卷中 1930 年在柯尼斯堡的演讲的结尾，Awodey 和 Carus 2001 和 Goldfarb 2005）。 塔斯基在类型论中有一个版本的可定义性定理（参见 Hodges 2008）。 参见 Schiemer and Reck 2013。

我们有类型 0 的对象、个体的对象、类型 1 的对象、个体的类的对象、类型 2 的对象、个体的类的对象，等等。像关系一样，有两个或多个参数的函数不需要包含在原始对象中，因为可以将关系定义为有序对的类，而将有序对定义为类的类。 For example, the ordered pair of individuals _a, b_ can be defined to be {{a},{a,b}}{{a},{a,b}}\\{\\{a\\},\\{a,b\\}\\} where {x,y}{x,y}\\{x,y\\} denotes the class whose sole elements are xxx and yyy. （维纳在 1914 年曾提出过类似的将关系简化为类的方法。） 在这个系统中，所有的命题都有 a（b）a（b）a（b）的形式，其中 bbb 是 n+1n+1n+1 型的符号，bbb 是 nnn 型的符号。 因此，这个系统是建立在一个给定域的对象的任意类或子集的概念上，并且建立在给定域的所有子集的集合可以形成下一个类型的新域的事实上。 从给定的个体域开始，然后迭代该过程。 正如 Scott 1993 年所强调的，在集合论中，形成子集的过程被迭代到*transfinite*。

在这些版本的类型论中，就像在集合论中一样，函数不是原始对象，而是表示为函数关系。 例如，加法函数被表示为类型为（i，i，i）（i，i，i）（i，i，i）的对象的三元关系。 一个优雅的制定简单的类型理论，它扩展了它的介绍功能作为原始对象是由教会在 1940 年。 它使用 λ λ\lambda\-演算符号（Barendregt 1997）。 由于这样的公式在计算机科学中很重要，与范畴论和马丁-勒夫型理论的联系，我们在一些细节上描述它。 在这个公式中，谓词被看作是一种特殊的函数（命题函数），这一思想可以追溯到弗雷格（例如，参见奎因 1940）。 此外，函数的概念被认为比谓词和关系的概念更原始，函数不再被定义为一种特殊的关系。 （Oppenheimer and Zalta 2011 提出了一些反对这种原始函数表示的论点。 该系统的类型归纳定义如下

1.  有两种基本类型 iii（个人类型）和 ooo（命题类型）
2.  如果 A，BA，BA，B 是类型，则 A→BA→BA \\rightarrow B，从 AAA 到 BBB 的函数的类型，是类型

我们可以用这种方式来形成类型：

|                                                     |                    |
| --------------------------------------------------- | ------------------ |
| i→oi→oi\\rightarrow o                               | （谓词类型）       |
| （i→o）→o（i→o）→o（i\\rightarrow o）\\rightarrow o | （谓词的谓词类型） |

其对应于类型（i）（i）（i）和（（i））（（i））（（i）），但也对应于新类型

|                                                     |              |
| --------------------------------------------------- | ------------ |
| i→ii→ii\\右箭头 i                                   | （职能类型） |
| （i→i）→i（i→i）→i（i\\rightarrow i）\\rightarrow i | （泛函类型） |

写起来方便

A1，.，An → BA1，.，An →B A_1，\\ldots，A_n \\rightarrow B

为

A1→（A2→...→（An→B））A1→（A2→...→（An→B））A_1 \\rightarrow（A_2 \\rightarrow \\ldots \\rightarrow（A_n \\rightarrow B））

以这种方式

A1，.，An → oA1，.，An →o A_1，\\ldots，A_n \\rightarrow o

对应于类型（A1，.，An）（A1，.，An）（A_1，\ldots，A_n）。

一阶逻辑只考虑以下形式的类型

|                                                    |                        |     |
| -------------------------------------------------- | ---------------------- | --- |
| i，...，i→ii，...，i→ii，\\ldots，i \\right 箭头 i | （功能符号的类型），   | 和  |
| i，.，i→oi，.，i→oi，\\ldots，i \\rightarrow o     | （谓词类型、关系符号） |     |

注意到

A→B→CA→B→C A \\rightarrow B \\right arrow C

代表

A→（B→C）A→（B→C）A \\rightarrow（B\\rightarrow C）

（右）。

对于这种逻辑的条款，我们将不遵循教会的帐户，但它的轻微变化，由于库里（谁有类似的想法之前，教会的文件出现），并详细介绍了 R。 辛德雷关于类型理论的书 像 Church 一样，我们使用 λλ\\lambda\-演算，它为函数提供了一个通用符号

M：：\=x <$MM <$λx.MM：：=x <$MM <$λx.M M M：：= x \\mid M M \\mid \\lambda x.M

这里我们使用了所谓的 BNF 符号，在计算科学中非常方便。 这给出了 λλ\\lambda\-项的语法规范，当扩展时，意味着：

-   每个变量都是一个函数符号;
-   两个功能符号的每一个并置都是一个功能符号;
-   每个 λx.Mλx.M\\lambda x.M 是函数符号;
-   没有其他功能符号。

函数应用程序的符号 MNMNM N 与数学符号 M（N）M（N）M（N）略有不同。 总的来说，

M1M2M3M1M2M3 M_1 M_2 M_3

代表

（M1M2）M3（M1M2）M3（M_1 M_2）M_3

（左起）。 项 λx.Mλx.M\\lambda x.M 表示将 M\[x：\=NM\[x：=N\]关联到 NNN 的函数。 这种符号是如此方便，以至于人们想知道为什么它在数学中没有被广泛使用。 则 λλ\\lambda\-演算的主要方程是（β（β（\\beta\-转换））

（λ x. M）N\= M\[x：\= N\]（λ x. M）N\= M\[x：= N\]（\\lambda x. M）N = M\[x：= N\]

它将 λx.Mλx.M\\lambda x.M 的意义表示为一个函数。 我们已经使用 M\[x：\=NM\[x：=NM\[x：=N\]作为当 NNN 替换矩阵 MMM 中的变量 xxx 时得到的表达式的值的符号。 人们通常将此等式视为重写规则（β（β（\\beta\-reduction）

（λx.M）N→M\[x：\=N\]（λx.M）N→M\[x：=N\]（\\lambda x.M）N \\rightarrow M\[x：=N\]

在*untyped* lambda 演算中，这种重写可能不会终止。 典型的例子是由项 Δ\=λx.xxΔ\=λx.xx\\Delta = \\lambda x.x x 和应用程序给出的。

ΔΔ→Δ →ΔΔ\Delta \\Delta\\rightarrow \\Delta \\Delta

（注意与罗素悖论的相似之处。 Curry 的思想是将类型视为 lambda 项上的谓词，编写 M：AM：AM：A 来表示 MMM 满足谓词/类型 AAA。 的意义

N：A→BN：A→B N：A\\右箭头 B

然后

M，if M：A then NM：B

这证明了以下规则的合理性

N：A→BM：ANM：BN：A→BM：ANM：B \\frac{N：A\\rightarrow B M：A}{N M：B} M：B\[x：A\]λx.M：A→BM：B\[x：A\]λx.M：A→B \\frac{M：B \[x：A\]}{\\lambda x.M：A \rightarrow B}

一般来说，人们是用形式的判断来工作的。

x1：A1，.，xn：An AWM：Ax1：A1，.，xn：An_xM：A x_1：A_1，.，x_n：A_n \\vdash M：A

其中 x1，.，xnx1，.，xnx_1，...， X1-n 是不同的变量，并且 MMM 是具有 X1，.，xnx1，.，xnx_1，...， x_n。 为了能够得到丘奇系统，人们增加了一些常数，以形成命题。 通常

|              |                                                     |
| ------------ | --------------------------------------------------- |
| 不是：       | o→oo→oo\\rightarrow o                               |
| 暗示：       | o→o → o →o → o\\rightarrow o\\rightarrow o          |
| 以及：       | o→o → o →o → o\\rightarrow o\\rightarrow o          |
| 对于所有人： | （A→o）→o（A→o）→o（A\\rightarrow o）\\rightarrow o |

术语

λx.<$（xx）λx.<$（xx）\\lambda x. \\neg（x x）

表示不适用于自身的谓词的谓词。 然而，这个术语没有类型，也就是说，不可能找到 AAA，使得

λx.<$（xx）：（A→o）→oλx.<$（xx）：（A→o）→o \\lambda x. \\neg（x x）：（A\\rightarrow o）\\rightarrow o

这是罗素悖论无法表达的事实的形式化表达。 莱布尼茨等式

Q：i→i→ o Q：i→i→o Q：i \\rightarrow i \\rightarrow o

将被定义为

Q\=λx.λy.<$（λP.imply（Px）（Py））Q\=λx.λy.<$（λP.imply（Px）（Py））Q = \\lambda x . \\lambda y. \\forall（\\lambda P.\\隐含（P x）（P y））

我们通常写<$x\[M <$x\[M\\forall x\[M\]而不是<$（λ x.M）<$（λx.M）\\forall（\\lambda x.M），QQQ 的定义可以重写为

Q\=λx.λy.<$P\[imply（Px）（Py）\]Q\=λx.λy.<$P\[imply（Px）（Py）\] Q = \\lambda x.\\ lambda y.对于所有 P\[\\imply（Px）（PY）\]

这个例子再次说明了我们可以在简单类型理论中制定非断言定义。

λλ\\lambda\-项和 ββ\\beta\-归约的使用对于表示简单类型论中所需的复杂替换规则是最方便的。 例如，如果我们想用谓词 λx.Qaxλx.Qax\\lambda x.Q a x 替换命题中的 PPP，

隐含（Pa）（Pb）隐含（Pa）（Pb）\\隐含（P a）（P b）

我们得到

imply（（λx.Qax）a）（（λx.Qax）b）imply（（λx. Qax）a）（（λx.Qax）b）\\imply（（\\lambda x.Q a x）a）（（\\lambda x.Q a x）b）

并且，使用 ββ\\β\-还原，

implement（Qaa）（Qab）implement（Qaa）（Qab）\\implement（Q a a）（Q a b）

总之，简单类型理论禁止自应用，但不禁止非谓词定义中的循环。

λλ\\lambda\-演算形式主义也允许对罗素悖论进行更清晰的分析。 我们可以把它看作谓词的定义

Rx\=<$（xx）Rx\=<$（xx）R x = \\neg（x x）

如果我们把 ββ\\beta\-归约看作是展开一个定义的过程，我们就会发现理解 R R 的定义已经有问题了。

RR→ <$（RR）→ <$（<$（RR））→. RR→ <$（RR）→ <$（<$（RR））→. R R \\rightarrow \\neg（R R）\\rightarrow \\neg（\\neg（R R））\\rightarrow \\ldots

从某种意义上说，我们有一个没有充分根据的定义，它就像矛盾（一个等价于其否定的命题）一样成问题。 一个重要的定理，规范化定理，说这不可能发生在简单类型上：如果我们有 M：AM：AM：A，那么 MMM 是强规范化的（任何从 MMM 开始的约简序列终止）。

关于这个主题的更多信息，我们参考 Church 的简单类型理论。

## 3\. 分支层次与非谓原则

罗素引入了另一个层次，这不是由正式系统中表达的任何正式悖论所驱动的，而是由对“循环”的恐惧和类似于说谎者悖论的非正式悖论所驱动的。 如果一个人说“我在撒谎”，那么我们就有了一个让人想起罗素悖论的情况：一个等价于自身否定的命题。 另一个非正式的这种矛盾的情况是，如果我们定义一个整数是“最小的整数不能定义在少于 100 个字”。 为了避免这种非正式的悖论，罗素认为有必要引入另一种等级制度，即所谓的“分歧等级制度”。 罗素（1903）的附录 B 暗示了这种层次结构的必要性。 有趣的是，这与等价命题的同一性问题和一类命题的逻辑积问题有关。 罗素（1959）的第 10 章对此进行了详细的讨论。 由于这个分歧层次的概念在逻辑，特别是证明理论中非常有影响力，我们将详细描述它。

为了进一步激发这种层次结构，这里有一个罗素的例子。 如果说

拿破仑是科西嘉人。

我们在这句话中不涉及任何属性的集合。 “成为科西嘉人”这一性质被认为是表语性的。 如果我们说另一方面

拿破仑具有伟大将军的所有品质

我们指的是品质的整体。 “具有伟大将军的所有品质”的性质被称为是不可预测的。

另一个例子，也来自罗素，展示了不可断言的性质如何可能导致让人想起说谎者悖论的问题。 假设我们提出定义

一个典型的英国人是一个拥有大多数英国人所拥有的所有财产的人。

很明显，大多数英国人并不拥有大多数英国人所拥有的所有财产。 因此，根据这个定义，一个典型的英国人应该是不典型的。 根据罗素的观点，问题在于“典型”这个词被定义为所有属性的引用，并且被视为本身就是一种属性。 (It 值得注意的是，在定义*random* numbers 的概念时出现了类似的问题，参见。 Martin-Löf《关于构造数学的笔记》（1970）。 罗素引入了分歧层次，以处理这种非谓词定义的明显循环。 人们应该区分*first-order* properties，就像科西嘉人一样，不涉及属性的整体，并认为*second-order* properties 只涉及*first-order_properties*的整体。 然后我们可以引入三阶性质，它可以指二阶性质的全体，等等，这就清楚地排除了所有与非谓词定义有关的循环。

大约在同一时间，庞加莱进行了类似的分析。 他强调了“谓词”分类的重要性，以及不使用量化来定义类的元素的重要性（庞加莱 1909）。 庞加莱用了下面的例子。 假设我们有一个包含元素 0，1 和一个操作+的集合，

x+0\=0x+（y+1）\=（x+y）+1x+0\=0x+（y+1）\=（x+y）+1\\begin{align} x+0 &= 0 \ x+（y+1）&=（x+y）+1 \\end{align}

假设一个性质是*inductive*，如果它对 0 成立，并且对 x+1x+1x+1 成立，如果它对 xxx 成立。

一个非断言的，并且可能是“危险的”定义是，如果一个元素满足*all* inductive 属性，则将其定义为*number*。 这样就很容易证明这个“成为一个数”的性质本身就是归纳的。 事实上，0 是一个数，因为它满足所有归纳性质，如果 xxx 满足所有归纳性质，那么 x+1x+1x+1 也满足所有归纳性质。 类似地，如果 x，yx，yx，y 是数，则很容易证明 x+yx+yx+y 是数。 事实上，Q（z）Q（z）Q（z）是一个数的性质是归纳的：QQQ（0）成立，因为 x+0\= xx +0\=xx+0=x，如果 x+zx+zx + z 是一个数，那么 x+（z+1）\=（x+z）+1x+（z+1）\=（x+z）+1x+（z+1）=（x+z）+1。 然而，这整个论证是循环的，因为“成为一个数”的性质不是表语性的，应该被怀疑地对待。

相反，我们应该引入一个由属性和数字组成的分支层次。 在开始时，人们只有一阶归纳性质，在它们的定义中并不涉及性质的总体，并且人们定义 1 阶数是满足所有一阶归纳性质的元素。 接下来可以考虑二阶归纳性质，它可以指一阶性质的集合，以及 2 阶数，它是满足 2 阶归纳性质的元素。 庞加莱强调了这样一个事实，即一个 2 阶数更有可能是一个 1 阶数，更一般地说，一个 n+1n+1n+1 阶数更有可能是一个 nnn 阶数。 因此，我们有一个越来越受限制的性质序列：阶数为 1，2，.的归纳性质，以及一个越来越受限制的对象集合序列：阶数为 1，2，.

似乎不可能证明 x+yx+yx+y 是 nnn 阶数，如果 x，yx，yx，y 是 nnn 阶数。 另一方面，可以证明如果 xxx 是 n+1n+1n+1 阶数，yyy 是 n+1n+1n+1 阶数，则 x+yx+yx+y 是 nnn 阶数。 实际上，“x+zx+zx+z 是 nnn 阶数”的性质 P（z）P（z）P（z）是 n+1 阶的归纳性质：Pn+1：Pn+1：P（0）成立，因为 x+0\= xx +0\=xx+0 = x 是 n+1n+1n+1 阶数，因此是 nnn 阶数，如果 P（z）P（z）P（z）成立，即如果 x+zx+zx+z 是 nnn 阶数，则 x+（z+1）\=（x+z）+1x+（z+1）\=（x+z）+1x+（z+1）=（x+z）+1，因此 P（z +1）P（z +1）P（z+1）成立。 由于 yyy 是 n+1n+1n+1 阶数，P（z）P（z）P（z）是 n+1 阶归纳性质，P（y）n +1，P（y）n+1 成立，所以 x+yx+yx+y 是 nnn 阶数。 这个例子很好地说明了分歧层次结构所带来的复杂性。

如果有人像罗素对弗雷格那样，甚至把自然数这样的基本对象也定义为类的类，那么复杂性就会进一步放大。 例如，数字 2 被定义为具有恰好两个元素的所有类别的个体的类别。 我们再次得到分歧层次中不同阶的自然数。 除了罗素本人，尽管所有这些并发症，Chwistek 试图发展算术的一个分歧的方式，和利益的这种分析强调了 Skolem。 最近的发展见 Burgess 和 Hazen（1998）。

另一个数学例子，经常给出，一个非谓词定义是定义的最小上限的有界类的实数。 如果我们用小于这个实数的有理数的集合来标识一个实数，我们看到这个最小上界可以定义为这个类中所有元素的并集。 让我们把有理数的子集确定为谓词。 例如，对于有理数 q，P（q）q，P（q）q，P（q）成立当且仅当 qqq 是 PPP 子集的成员。 现在，我们定义谓词 LCLCL_C（有理数的子集）为类 CCC 的最小上界：

<$q\[LC（q）Participant P\[C（P）<$P（q）\]<$q\[LC（q）Participant P\[C（P）<$P（q）\] \\for all q\[L_C（q）\\leftrightarrow \\exists P\[C（P）\\wedge P（q）\]\]

这是非谓词的：我们已经通过对所有谓词的存在量化定义了谓词 LLL。 在分歧层次中，如果 CCC 是一阶有理数类，则 LLL 是二阶有理数类。 然后得到的不是*one* notion 或实数，而是不同阶数的实数 1，2，..

正如我们前面看到的，莱布尼茨的平等定义给出了另一个非谓词定义的例子。 对于莱布尼茨，谓词“等于”是真的 bbb 当且仅当 bbb 满足所有谓词满足。

人们应该如何处理分歧的等级制度所带来的复杂情况呢？ 罗素在[《数学原理》](../principia-mathematica/)第二版的导言中指出，这些复杂情况在某些情况下是可以避免的。 他甚至认为，在附录 B 的第二版的数学原理，分歧层次的自然数秩序 1，2，.崩溃在秩序 5 定义自反传递封闭的关系。 然而，哥德尔后来在他的论证中发现了一个问题，事实上，Myhill（1974）证明了这个层次结构实际上在任何有限的水平上都不会崩溃。 罗素在[《数学原理》](../principia-mathematica/)第二版的导言中讨论了一个类似的问题，即康托定理的证明，即从所有谓词的集合到所有对象的集合不可能有任何单射函数（我们在导言中提出的弗雷格系统中的罗素悖论）。 这可以在一个分支的层次结构中完成吗？ 罗素怀疑这可以在谓词的分支层次中完成，这一点后来确实得到了证实（参见 Chwistek 1926，Fitch 1939 和 Heck 1996）。

由于这些问题，罗素和怀特海在第一版的《数学原理》中引入了以下的归约公理：谓词的层次，一阶、二阶等， 在第一层崩溃。 这意味着对于任何顺序的谓词，都有一个一阶谓词与之等价。例如，在等式的情况下，我们假设一个一阶关系“a\=ba\=ba=b”，它等价于“a 满足 bbb 满足的所有性质”。 这一公理的动机纯粹是务实的。 没有它，所有基本的数学概念，如实数或自然数，都被分成不同的顺序。 此外，尽管非断言定义的循环性很明显，但归约公理似乎并不导致不一致。

然而，正如 Chwistek 和 Ramsey 首先注意到的那样，在归约公理的存在下，实际上根本没有必要引入分歧层次！ 从一开始就接受非断言定义要简单得多。 简单的“外延”层次的个人，类，类的类，.然后就足够了。 这样，我们就得到了在哥德尔（1931）或丘奇（1940）中形式化的更简单的系统。

归约公理使人们注意到非谓定义的问题状态。 引用外尔 1946 年的话，还原公理“是一个大胆的，几乎是一个荒谬的公理;在我们生活的现实世界中，几乎没有理由证明它，在我们的头脑建立其结构的证据中根本没有”！ 到目前为止，使用归约公理还没有发现矛盾。 然而，正如我们下面将要看到的，证明论的研究证实了这样一个原则的极端力量。

分歧层次的思想在数理逻辑中一直是极其重要的。 罗素只考虑了层次的有限迭代：一阶、二阶等等， 但从一开始就考虑了扩展分支 transmittance 的可能性。 庞加莱（1909 年）提到的工作柯尼希在这个方向。 对于上面不同阶数的例子，他还定义了一个阶为 ω ω\\omega 的数是归纳的，如果它是所有有限阶的归纳数。 然后，他指出，*x+y*是归纳的阶 ωω\\omega，如果 xxx 和 yyy 都是。 这表明超限阶的引入在某些情况下可以起到归约公理的作用。 哥德尔进一步分析了分歧层次的这种超限扩展，他注意到以下形式的归约公理实际上是可证明的：当人们将自然数上的性质分歧层次扩展到超限时，这个层次在最小不可数序数 ω1ω 1\\omega\1 级坍塌（哥德尔 1995，普拉维茨 1970）。 此外，虽然在所有<ω1<ω 1\\lt\\omega_1 的水平上，谓词的集合是可数的，但在水平 ω1ω1\\omega_1 上的谓词的集合具有基数 ω1ω 1\\omega_1。 这一事实是哥德尔的可构造集模型背后的一个强大动机。 在这个模型中，自然数集合的所有子集的集合（由谓词表示）具有基数 ω1ω 1\\omega_1，并且类似于分歧层次。 该模型以这种方式满足连续统假设，并给出了这一公理的相对一致性证明。 (The 哥德尔的动机最初只是建立一个模型，其中所有自然数子集的集合都是有序的。

分歧层次也一直在证明理论的许多工作的来源。 在根森发现算术的一致性可以通过超限归纳法（在可判定谓词上）沿着序数 ε0ε 0\\varepsilon_0 证明之后，自然的问题是为分歧层次的不同层次找到相应的序数。 Schütte（1960）发现，对于分歧层次的第一层，也就是说，如果我们通过仅对一阶性质进行量化来扩展算术，我们得到一个序数强度为 εε0εε 0\\varepsilon\_{\\varepsilon_0}的系统。 对于第二个级别，我们得到序数强度 ε 0εε 0\\varepsilon\_{\\varepsilon\_{\\varepsilon_0}}等。我们记得 εαεα\\varepsilon\_{\\alpha}表示 αα\\alpha 第 ε\\varepsilon\-序数，εε\\varepsilon\-序数是序数 ββ\\beta，使得 ωβ\=β\\omega^{\beta} = \\beta，参见 Schütte（1960）。

哥德尔强调了这样一个事实，即他对连续统假设问题的研究方法不是构造性的，因为它需要不可数序数 ω1ω 1\\ω 1，并且沿着构造性序数研究分歧的层次是很自然的。 在 Lorenzen 和 Wang 的初步工作之后，Schütte 分析了如果我们以以下更具建设性的方式进行会发生什么。 由于算术对于序数强度 ε0ε0\\varepsilon_0 有，我们首先考虑分枝族直到 ε0ε 0\varepsilon_0 的迭代。 Schütte 计算了得到的系统的序强度，并找到了序强度 u（1）\> ε 0u（1）\>ε 0u（1）\\gt\\varepsilon_0。 然后，我们将层次分枝到这个序数 u（1）u（1）u（1），得到一个序数强度系统 u（2）\> u（1）u（2）\>u（1）u（2）\\gt u（1），等等。每个 u（k）u（k）u（k）可以用所谓的 Veblen 层次计算：u（k+1）u（k +1）u（k +1）是<$u（k）（0）<$u（k）（0）\\phi\_{u（k）}（0）。 这个过程的极限给出了一个序数，叫做 Γ0Γ0\\Gamma_0：如果我们把这个分歧的层次结构推广到序数 Γ0Γ0\\Gamma_0，我们得到一个序数强度为 Γ0Γ0\\Gamma_0 的系统。 这样一个序数大约在同一时间由 S 独立地得到。 费弗曼 有人声称，Γ0Γ 0\\Gamma_0 对谓词系统的作用类似于 ε0ε 0\\varepsilon_0 对算术系统的作用。 然而，最近的证明理论工作关注的是具有更大的证明理论序数的系统，这些序数可以被认为是谓词的（例如参见 Palmgren 1995）。

除了这些证明理论的调查有关的分歧层次，大量的工作一直致力于证明理论的一致性分析公理的 reductions，或等价的，一致性的 impredicative 定义。 继根岑对切消性质的分析之后，Takeuti 发现了简单类型理论（没有分支）的一个优雅的切消公式，并大胆猜想切消应该适用于这个系统。 这个猜想一开始似乎非常可疑，因为非谓词量化的循环性，这在这个形式主义中得到了很好的反映。 量化的规则确实是

\[A（X）\]\[X：\=T\]\[A（X）\] \\frac{\\Gamma \\vdash \\for all X\[A（X）\]}\\Gamma \\vdash A\[X：=T\]}

其中 TTT 是*any* term 谓词，其本身可以涉及对所有谓词的量化。 因此，公式 A\[X：\=T\] A\[X：=T\]A\[X：=T\]本身可能比公式 A（X）A（X）A（X）复杂得多。

一个早期的结果是 Takeuti 非谓系统的割消以有限的方式蕴涵了二阶算术的相容性。 (One 表明这意味着无穷公理的适当形式的一致性，参见 Andrews 2002。 继舒特（Schütte，1960 年 b）的工作之后，W. Tait 和 D. Prawitz 证明切消性质确实成立（这个证明必须使用更强的证明理论原则，因为它应该根据不完全性定理。

这里重要的是，这些研究揭示了非述量化的极端力量，或者等价地，还原公理的极端力量。 这在某种程度上证实了庞加莱和罗素的直觉。 二阶算术的证明理论强度远远高于 Schütte 所考虑的算术的所有分支扩展。 另一方面，尽管在 Takeuti 的微积分中如此明确地提出了非谓词定义的循环性，但在二阶算术中还没有发现悖论。

证明论的另一个研究方向是理解有多少非断言量化可以从直觉主义数学中可用的原则中解释。 这些原则中最强的是归纳定义的强形式。 有了这样的原则，我们就可以解释一种有限形式的非谓词量化，称为理解，在这种理解中，我们只使用一个层次的非谓词量化来描述谓词。 有趣的是，几乎所有已知的非谓词量化的用法：莱布尼茨等式，最小上界等， 可以用 11 11\\Pi\_{1}^1\-理解完成。 这种对 Π11Π 11\\Pi\_{1}^1\-理解的简化首先由 Takeuti 以一种相当间接的方式实现，后来由 Buchholz 和 Schütte 使用所谓的 ΩΩ\\Omega\-规则进行简化。 它可以被看作是一个建设性的解释，一些限制，但不平凡的，使用非谓词定义。

## 4\. 类型理论/集合理论

类型论可以被用作数学的基础，事实上，它是由罗素在 1908 年的论文中提出的，该论文与策梅罗的论文同年发表，提出集合论作为数学的基础。

我们如何在集合论中解释类型论是很直观的：一个类型被简单地解释为一个集合，函数类型 A→BA→BA \\rightarrow B 可以用集合论中函数的概念（作为一种函数关系，即元素对的集合）来解释。 类型 A→oA→oA \\rightarrow o 对应于幂集运算。

另一个方向更有趣。 我们如何用类型来解释集合的概念呢？ 有一个优雅的解决方案，由于 A。 Miquel，它补充了 P.Aczel（1978）以前的工作，它也具有解释不一定有根据的 Finsler 集合的优势。 我们可以简单地将一个*set*解释为一个*pointed graph*（图中的箭头表示成员关系）。 这在类型论中非常方便地表示，一个点图简单地由类型 A 和一对元素给出

a：A，R：A→A→oa：A，R：A→A→o a：A，R：A \\rightarrow A \\rightarrow o

然后我们可以在类型论中定义当两个这样的集合 A，a，RA，a，RA，a，R 和 B，b，SB，b，SB，b，S 相等时：这是当且仅当 AAA 和 BBB 之间存在互模拟 TTT 使得 TabTabTab 成立。 互模拟是一种关系

T：A→B→oT：A→B→o T：A\\rightarrow B\\rightarrow o

使得每当 TxyTxyTxy 和 RxuRxuRxu 成立时，存在使得 TuvTuvTuv 和 SyvSyvSyv 成立 vvv，并且每当 TxyTxyTxy 和 RyvRyvRyv 成立时，存在使得 TuvTuvTuv 和 RxuRxuRxu 成立的 uuu。 然后我们可以定义隶属关系：表示为 B，b，SB，b，SB，b，S 的集合是表示为 A，a，RA，a，RA，a，R 的集合的成员当且仅当存在 a1a1a_1 使得 Ra1aRa1aRa_1 a 和 A，a1，RA，a1，RA，a_1，R 和 B，b，SB，b，SB，b，S 是双相似的。

然后可以检查，所有集合论的一般公理外延性，幂集，并，有界公式上的理解（甚至是反基础，因此隶属关系不需要有良好的基础）在这个简单的模型中成立。 （有界公式是一个公式，其中所有的量化都是以下形式：<$x ∈ a...<$x∈a...\\forall x \\in a\\ldots 或<$x∈a...<$x∈a...\\exists x \\in a\\ldots）。 通过这种方式，它可以表明，教会的简单类型理论是 equiconsistent 与有界版本的策梅罗的集理论。

## 5\. 类型理论/范畴理论

类型论和范畴论之间有着深刻的联系。 我们仅限于介绍类型论在范畴论中的两个应用：自由 Carnival 闭范畴和自由 Topos 的构造（参见范畴论中关于“Carnival 闭”和“Topos”的解释）。

为了构造自由 Carnival 闭范畴，我们用类型 1（单位类型）和乘积类型 A×BA×BA × B 推广了简单类型论，得到了 A，BA，BA，B 类型. 这些术语通过增加配对运算和投影以及类型 1 的特殊元素来扩展。 在 Lambek 和 Scott 1986 中，我们可以定义一个*typed_transformations* between terms 的概念，并证明这个关系是可判定的。 然后我们可以证明（Lambek and Scott 1986），以类型作为对象，以从 AAA 到 BBB 的态射作为类型 A→BA→BA \\rightarrow B 的闭项集合（以转换作为相等）的范畴是自由范畴闭范畴。 这可以用来证明这个类别中的箭头之间的相等是可判定的。

教会类型理论也可以用来构建自由的拓扑结构。 为此，我们取 AAA 型的对象对 A，EA，EA，E 作为对象对，并建立一个部分等价关系，即一个闭项 E：A → A → oE：A \\rightarrow A \\rightarrow o，它是对称的和传递的. 我们把关系 R：A→ B → oR：A→B→oR：A\\rightarrow B\\rightarrow o 作为 A，EA，EA，E 和 B，FB，FB，F 之间的态射，它们是泛函的，使得对于任何满足 EaaEaaE a a 的 a：Aa：A，存在一个且只有一个 BBB 的（模 F）F）元素 bbb，使得 FbbFbbF b b 和 RabRabR a b. 对于子对象分类器，我们取对 o，Eo，Eo，E，其中 E：o → o → oE：o\\rightarrow o\\rightarrow o 定义为

EMN\= and（implyMN）（implyNM）EMN\= and（implyMN）（implyNM）E M N = \\text{ and }（\\imply\\，M N）（\\imply\\，N M）

然后，我们可以表明，这个范畴形成了一个 topos，实际上是自由 topos。

应该注意的是，Lambek 和 Scott 1986 中的类型理论使用了由 Henkin 引入并由 P.Andrews（2002）改进的类型理论的变体，其具有作为唯一逻辑连接符的扩展等式，即多态常数

eq：A→A→oeq：A→A→o \\text{eq}：A \\rightarrow A \\rightarrow o

并从这个连接词和常数 T、F：oT、F：oT、F：o 定义所有逻辑连接词。 例如，定义

对于所有的 P =\_{df} \\text{eq}（\\lambda x. T）P，

类型 ooo 中的相等是逻辑等价。

内涵表述的一个优点是它允许基于 λλ\\lambda\-演算的证明的直接记法（Martin-Löf 1971 and Coquand 1986）。

## 6\. 类型系统的扩展，多态性，parameters

我们已经看到了类型上的运算 A →→\rightarrow A →→\rightarrow o 与集合上的幂集运算之间的相似性。 在集合论中，幂集运算可以沿着累积层次遍历迭代。 因此，寻找类似的超限形式的类型论是很自然的。

丘奇的简单类型理论的一个这样的扩展是通过添加宇宙得到的（马丁-洛夫 1970）。 添加一个 universe 是一个*reflection* process：我们添加一个类型 UUU，它的对象是到目前为止所考虑的类型。 对于丘奇的简单类型理论，

o：U，i：U and A→B：U if A：U，B：Uo：U，i：U and A→B：U if A：U，B：U o：U，i：U \\text{ and } A\\rightarrow B：U \\text{ if } A：U，B：U

此外，AAA 是一个类型，如果 A：UA：UA：U。 然后我们可以考虑以下类型，

（A：U）→A→A（A：U）→A→A（A：U）\\rightarrow A \\rightarrow A

以及诸如

id\=λA.λx.x：（A：U）→A→Aid\=λA.λx.x：（A：U）→A→A \\text{id} = \\lambda A.\\ lambda x.x：（A：U）\\rightarrow A \\rightarrow A

函数 id 以“small”类型 A：UA：UA：U 和 AAA 类型的元素 xxx 作为参数，并输出 AAA 类型的元素。 更一般地，如果 T（A）T（A）T（A）是假设 A：UA：UA：U 下的类型，则可以形成依赖类型

（A：U）→T（A）（A：U）→T（A）（A：U）\\右箭头 T（A）

MMM 是这种类型意味着 MA：T（A）MA：T（A）M A：T（A）无论何时 A：UA：UA：U。 我们以这种方式得到扩展的类型理论，其强度是类似的一个策梅罗的集理论（米克尔 2001）。 更强大的宇宙形式被认为是在（Palmgren 1998）。 Miquel（2003）提出了一个与 Zermelo-Fraenkel 等价的强度类型理论。

一个非常强的宇宙形式是通过添加公理 U：UU：UU：U 得到的。 这是 P. Martin-Löf 在 1970 年提出的。 J.Y. Girard 指出，由此产生的类型理论作为一个逻辑系统是不一致的（Girard 1972）。 虽然起初似乎可以用所有集合的集合直接再现罗素悖论，但由于集合和类型之间的差异，这种直接悖论实际上是不可能的。 事实上，在这样一个系统中，矛盾的推导是微妙的，而且是相当间接的（尽管如 Miquel 2001 所指出的，它现在可以通过将集合表示为尖图而被简化为罗素悖论）。 J.Y. Girard 首先得到了一个较弱系统的悖论。 这一悖论后来得到了完善（Coquand 1994 和 Hurkens 1995）。 (The Barendregt 在 1992 年引入的纯类型系统的概念，便于得到这些悖论的清晰表述。 而不是公理 U：UU：UU：U，一个假设只有

（A：U）→T（A）：U（A：U）→T（A）：U（A：U）\\右箭头 T（A）：U

如果 T（A）：U\[A：U\]T（A）：U\[A：U\]T（A）：U \[A：U\]。 请注意循环性，实际上与分支层次结构拒绝的循环性是同一类型的：我们通过量化 UUU 的所有元素来定义 UUU 类型的元素。 例如，

（A：U）→A→A：U（A：U）→A→A：U（A：U）\\rightarrow A \\rightarrow A：U

将是多态恒等函数的类型。 尽管如此，J.Y. Girard 能够用这种形式的多态性展示类型系统的规范化。 然而，丘奇的简单类型论的多态性扩展作为一个逻辑系统是不一致的，即所有命题（o 型项）都是可证明的。

J.Y. Girard 考虑多态类型系统的动机是将哥德尔的 Dialectica（哥德尔 1958）解释扩展到二阶算术。 他证明了规范化使用 reducibility 的方法，已介绍了泰特（1967 年），而分析哥德尔 1958 年。 值得注意的是，不可预测性中固有的循环性并没有导致不可规范化的术语。 （Girard 的论证随后被用来证明割消终止于上面提到的 Takeuti 的微积分。 一个类似的系统是由 J. Reynolds（1974）在分析计算机科学中多态性的概念时独立引入的。

马丁-洛夫对所有类型中的一个类型的引入来自于库里和霍华德的工作所建议的对命题和类型概念的识别。 这里值得回顾他的三个激励点：

1.  罗素把类型定义为命题函数的意义范围
2.  一个人需要量化所有命题的事实（简单类型理论的不可预测性）
3.  命题和类型识别

给定（1）和（2），我们应该有一种类型的命题（如在简单类型论中），给定（3），这也应该是所有类型的类型。 吉拉德悖论表明，一个人不可能同时拥有（1）、（2）和（3）。 马丁-勒夫的选择是拿走（2），将类型论限制为谓词（事实上，宇宙的概念首先出现在类型论中，作为所有类型的类型的谓词版本）。 Coquand（1986）讨论了取走（3）的另一种选择。

## 7\. 单价基础

类型论、集合论和范畴论之间的联系通过关于单价基础（Voevodsky 2015）和单价公理（Axiom of Univalence）的工作得到了新的认识。 这在本质上涉及到前一节中描述的类型论的扩展，特别是依赖类型，命题作为类型的观点，以及类型论域的概念。 这些发展也与讨论结构概念有关，例如罗素（1959）就强调了结构概念的重要性。

Martin-Löf 1975 \[1973\]引入了一个新的基本类型 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b），如果 bbb 和 bbb 在 AAA 类型中，它可以被认为是元素 bbb 和 bbb 的等式证明类型。 这种新类型的一个重要特征是它可以迭代，因此我们可以考虑类型 IdIdA（a，b）（p，q）IdIdA（a，b）（p，q）\\mathbf {Id}\_{\\mathbf {Id}\_A（a，b）}（p，q），如果 ppp 和 qqq 是 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）。 如果我们把一个类型看作是一种特殊的集合，那么很自然地会猜想这样一种类型的等式证明总是存在于任何两个等式证明 ppp 和 qqq 中。 事实上，直觉上，似乎至多存在两个元素 bbb 和 bbb 之间的相等证明。 令人惊讶的是，Hofmann 和 Streicher 在 1996 年设计了一个依赖类型理论的模型，在这个模型中，这是无效的，这是一个模型，在这个模型中，它们可以是两个元素相等的不同证明。 在这个模型中，类型由 a *groupoid*解释，类型 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）由 bbb 和 bbb 之间的同构集合解释，该集合可以有多个元素。 这个模型的存在有一个结果，即在类型论中一般不能证明一个相等类型最多有一个元素。 这个广群的解释已经以下面的方式推广，它给出了单位类型的直观解释。 A *type*被解释为一个拓扑空间*，直到同伦，类型 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）被解释为连接 bbb 和 bbb 的\_paths*的类型。 (See Awodey et al. 2013 and \[HoTT 2013，Other Internet Resources\].）

Voevodsky 2015 引入了以下类型分层。 (This 分层的部分动机是将类型解释为拓扑空间，但可以直接理解而不参考这种解释。 我们说 AAA 类型是 a _proposal_，如果我们有 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）对于 AAA 的任何元素 bbb 和 bbb（这意味着 AAA 类型最多有一个元素）。 我们说一个类型 AAA 是 a _set_，如果类型 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）是 AAA 的任何元素 bbb 和 bbb 的命题。 如果类型 IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）是 AAA 的任意元素 bbb 和 bbb 的集合，我们称 AAA 类型是 a _groupoid_。 这个术语的理由是，它可以证明，只有使用类型论的规则，任何这样的类型确实可以被视为通常范畴意义上的广群，其中对象是这个类型的元素，在 bbb 和 bbb 之间的态射集合由*set* IdA（a，b）IdA（a，b）\\mathbf{Id}\_A（a，b）表示。 复合是等式传递性的证明，恒等态射是等式自反性的证明。 每个态射都有一个逆的事实对应于恒等式是一个对称关系的事实。 这种分层可以扩展，我们可以定义什么时候类型是 2-广群，3-广群等等。在这种观点中，*type theory*出现作为一个巨大的推广*set theory*，因为一个集合是一种特殊的类型。

Voevodsky 2015 还引入了*equivalence* between types 的概念，这个概念以统一的方式推广了*logical equivalence* between proposals，_bijection_ between sets，_categorical equivalence_ between groupoid 等概念。我们说映射 f：A → Bf：A→ Bf：A\\rightarrow B 是等价的，如果对于 BBB 中的任何元素 bbb，对 a，pa，pa，p 的类型，其中 ppp 是 IdB（fa，b）IdB（fa，b）\\mathbf{Id}\_B（f a，b），是一个命题并且是被占据的。 这以一种强有力的方式表达了 BBB 中的一个元素是 AAA 中恰好一个元素的像，并且如果 AAA 和 BBB 是集合，我们恢复了集合之间双射的通常概念。 (In 一般如果 f：A→ Bf：A→Bf：A\\rightarrow B 是等价的，那么我们有一个映射 B→AB→AB\\rightarrow A，它可以被认为是 fff 的逆。 例如，可以证明恒等映射总是等价的。 设 Equiv（A，B）Equiv（A，B）\\text{Equiv}（A，B）是对 f，pf，pf，p 的类型，其中 f：A → Bf：A → Bf：A\\rightarrow B 和 ppp 是 fff 是等价的证明。 利用恒等映射是等价的这一事实，我们对任何类型的 AAA 都有 Equiv（A，A）Equiv（A，A）\\text{Equiv}（A，A）的元素。 这意味着我们有一张地图

IdU（A，B）→Equiv（A，B）IdU（A，B）→Equiv（A，B）\\mathbf{Id}\_U（A，B）\\rightarrow \\text{Equiv}（A，B）

而《单性公理》指出这个映射是等价的。 特别是，我们有这样的暗示，

Equiv（A，B）→IdU（A，B）Equiv（A，B）→IdU（A，B）\\text{Equiv}（A，B）\\rightarrow \\mathbf{Id}\_U（A，B）

所以如果两个小类型之间存在等价性，那么这些类型是相等的。

这个公理可以被看作是外延性原理的一种强形式。 它确实推广了 Church（1940）提出的命题外延公理，即两个逻辑等价的命题是等价的。 令人惊讶的是，它还暗示了*函数可拓性*公理，Church 1940 中的公理 10，它指出两个逐点相等的函数是相等的（Voevodsky 2015）。 它还直接暗示两个同构集相等，两个范畴等价的广群相等，等等。

这可以用来给出一个公式的概念*运输的结构*（布尔巴基 1957）沿等价。 例如，设 MAMAM A 是集合 AAA 上的幺半群结构的类型：这是元组 m，e，pm，e，pm，e，p 的类型，其中 mmm 是 AAA 上的二元运算，并且是 AAA 的元素，ppp 是这些元素满足通常幺半群定律的证明。 等价替换规则的形式是

IdU（A，B）→MA→MBIdU（A，B）→MA→MB \\mathbf{Id}\_U（A，B）\\rightarrow M A\\rightarrow M B

如果 AAA 和 BBB 之间存在一个双射，则根据单叶公理，它们是相等的，并且我们可以利用这个蕴涵将 AAA 的任何幺半群结构输运到 BBB 的幺半群结构中。

罗素（1919）和罗素（1959）都强调了结构概念的重要性。 例如，在罗素 1919 年的第六章中，人们注意到两个相似的关系本质上具有相同的性质，因此具有相同的“结构”。 (The 关系的“相似性”概念是在罗素 1901 年提出的。 我们也可以用这个框架来完善罗素关于结构概念的讨论。 例如，令**Monoid**是对 A，pA，pA，p 的类型，其中 ppp 是 MAMAM A 的元素。 两个这样的对 A，pA，pA，p 和 B，qB，qB，q 是同构的，如果存在从 AAA 到 BBB 的双射 fff，使得 qqq 等于 ppp 结构沿 fff 的迁移。 单价公理的一个推论是，两个同构的幺**半群**类型的元素是相等的，因此共享相同的属性。 请注意，当结构在集合论框架中被公式化时，这样的一般性质传输是不可能的。 事实上，在集合论的框架中，可以使用隶属关系来公式化属性，例如结构的载体集合包含自然数 000 的属性，通常不被同构保持的属性。 直觉上，一个结构的集合论描述是不够抽象的，因为我们可以谈论这个结构是如何建立起来的。 集合论和类型论之间的这种差异是 J.Reynolds 1983 将类型结构描述为“加强抽象层次的语法规则”的另一个例证。
